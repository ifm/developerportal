<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZZ08KXKV1G"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-ZZ08KXKV1G');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>How to verify the extrinsic calibration &mdash; O3R  documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/clipboard.min.js"></script>
        <script src="../../../../_static/copybutton.js"></script>
        <script src="../../../../_static/js/versionwarning.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="VPU extrinsic calibration" href="../VPUCalibration/README.html" />
    <link rel="prev" title="Automated camera head calibration tools" href="../MCC/multi_frame_calibration.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> O3R
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../GettingStarted/index_getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Firmware/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Technology/index_hardware_interfaces.html">Technology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../index_software_interfaces.html">Software Interfaces</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index_ods.html">ODS</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../getting_started.html">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Mounting/mounting.html">Mounting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Instantiation/instantiation.html">Instantiation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Configuration/configuration.html">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Zones/zones.html">Zones</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../OccupancyGrid/occupancy_grid.html">Occupancy grid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Recording/ods_data_recording.html">Recording</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangingViews/changing_views.html">Changing views</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../OverhangingLoads/overhanging_loads.html">Overhanging loads</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index_extrinsic_calibration.html">Extrinsic calibration</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../MCC/multi_frame_calibration.html">Automated camera head calibration tools</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">How to verify the extrinsic calibration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#concept-of-this-verification-method">Concept of this verification method</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#overview-of-extrinsic-calibration-angle-parameters-and-their-effect">Overview of extrinsic calibration angle parameters and their effect</a></li>
<li class="toctree-l5"><a class="reference internal" href="#how-to-calculate-the-expected-floor-plane-distances">How to calculate the expected floor plane distances?</a></li>
<li class="toctree-l5"><a class="reference internal" href="#measured-floor-plane-distance-and-rotated-reference-floor-plane-distances-comparison">Measured floor plane distance and rotated reference floor plane distances comparison</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#applications-of-this-extrinsic-calibration-verification-method">Applications of this extrinsic calibration verification method</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#cad-based-extrinsic-calibration-parameters">CAD based extrinsic calibration parameters</a></li>
<li class="toctree-l5"><a class="reference internal" href="#verifying-other-extrinsic-calibration-methods">Verifying other extrinsic calibration methods</a></li>
<li class="toctree-l5"><a class="reference internal" href="#sanity-checks-in-production-after-modification">Sanity checks: in production - after modification</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#example-application-of-the-extrinsic-calibration-verification-tool">Example application of the extrinsic calibration verification tool</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#max-allowed-rotation-angle-inaccuracy-1-1-deg">Max allowed rotation angle inaccuracy: [-1, +1] deg</a></li>
<li class="toctree-l5"><a class="reference internal" href="#max-allowed-rotation-angle-inaccuracy-3-3-deg">Max allowed rotation angle inaccuracy: [-3, +3] deg</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../VPUCalibration/README.html">VPU extrinsic calibration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../FieldTest/index_field_test.html">Field test</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../DeviceVerification/index_device_verification.html">Device verification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../iVA/index_ifmODS_iVA.html">ifmVisionAssistant</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Python/index_ifmODS_python.html">Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Cpp/index_ifmODS_cpp.html">C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../FAQ/FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../downloadable/index.html">History</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">O3R</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index_ods.html">ODS (Obstacle Detection System)</a> &raquo;</li>
          <li><a href="../index_extrinsic_calibration.html">Extrinsic calibration for ODS</a> &raquo;</li>
      <li>How to verify the extrinsic calibration</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/documentation/ODS/ExtrinsicCalibration/CameraCalibrationVerification/extrinsic_calibration_verification.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="tex2jax_ignore mathjax_ignore section" id="how-to-verify-the-extrinsic-calibration">
<h1>How to verify the extrinsic calibration<a class="headerlink" href="#how-to-verify-the-extrinsic-calibration" title="Permalink to this headline"></a></h1>
<p>A verification of the extrinsic calibration is a necessary step to ensure the best functionality and data quality of any distance based measurement sensor technology.</p>
<p>Such verification can be done by using the same tools as estimating the extrinsic calibration parameters. This however increases the complexity and effort to provide reproducible calibration conditions in the field, where such verification is required.</p>
<p>Alternative methods should be based on simpler approaches where calibration conditions don’t depend as much on external calibration tools, such as checkerboards and known geometric relations.
Such in situ methods should be based on natural geometric relations to the existing operation environment of the robot.</p>
<p>Below such a in situ method is described aimed at the verification of the extrinsic calibration of 3D cameras.</p>
<div class="section" id="concept-of-this-verification-method">
<h2>Concept of this verification method<a class="headerlink" href="#concept-of-this-verification-method" title="Permalink to this headline"></a></h2>
<p>This verification method is based on simple O3R ToF distance dataset and does not require any specific ODS data.
The users sets the 3D extrinsic calibration which is verified in using this procedure.</p>
<p>The concept behind this verification is to test a measured horizontal floor plane (to be present in the scene) for rotation validity in two angle directions: roll, and pitch angles in 3D space against a reference plane. For this purpose a reference floor plane is calculated based on the user input extrinsic calibration parameters and an a-priori knowledge of the intrinsic camera calibration parameters.</p>
<p>Rotating this reference floor plane with additional rotation matrices of the critical extrinsic calibration angles (in RCS space) provides the distance boundaries per pixel. The critical angles of the extrinsic calibration, i.e. precision required for ODS, determine the distance value boundaries per pixel.</p>
<p>For easier handling the problem statement is reduced by one spatial domain, i.e. reduced from a three dimensional problem statement to a two dimensional problem statement, by comparing measured floor plane distances vs. reference floor plane distances.</p>
<p>This method implicitly tests the extrinsic translation parameter in Z-component. The extrinsic translation parameters in X- and Y-components can not be tested.</p>
<div class="section" id="overview-of-extrinsic-calibration-angle-parameters-and-their-effect">
<h3>Overview of extrinsic calibration angle parameters and their effect<a class="headerlink" href="#overview-of-extrinsic-calibration-angle-parameters-and-their-effect" title="Permalink to this headline"></a></h3>
<p>Extrinsic calibration methods estimate the 6 degree of freedom (Dof) 3D pose of the camera in relation to a fixed point on in the robot coordinate system.</p>
<p>This includes two sets of extrinsic calibration parameters: 3 translation vectors in 3D space, and 3 rotation angles in 3D space.
For further details see the <span class="xref myst">whitepaper about extrinsic calibration methods for cameras</span>.</p>
<p>The presented method for extrinsic calibration verification validates 2 angle parameters: the roll and pitch angles in 3D space.</p>
<p>As a refresher, see the picture on angle definitions in 3D space below:</p>
<p><img alt="Roll pitch yaw angles" src="../../../../_images/roll_pitch_yaw.svg" /></p>
<p>The forward movement direction of the AGV / AMR coincides with indicated flight direction of the airplane in the picture above.
As can be intuitively seen only rotations in roll and pitch have a noticeable effect on an imagined horizontal plane at <code class="docutils literal notranslate"><span class="pre">Z==0</span></code>.</p>
<p>Hence only these rotation values can be verified with the method presented here.</p>
</div>
<div class="section" id="how-to-calculate-the-expected-floor-plane-distances">
<h3>How to calculate the expected floor plane distances?<a class="headerlink" href="#how-to-calculate-the-expected-floor-plane-distances" title="Permalink to this headline"></a></h3>
<p>To calculate an expected floor plane based on the cameras intrinsic and extrinsic calibration the following templates have to be used:</p>
<ol class="simple">
<li><p>Calculated unit vectors based on the cameras intrinsic calibration.</p></li>
<li><p>Rotate the unit vectors into the same orientation as the user specified Robot Coordinate System (RCS).</p></li>
<li><p>Calculate the expected floor plane distances based on the rotated unit vectors and the known extrinsic camera calibration parameter.</p></li>
</ol>
<p><strong>Unit vectors based on a Bouguet model</strong></p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="c1"># intrinsicModelID == 0  # Bouguet model</span>

<span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">k3</span><span class="p">,</span> <span class="n">k4</span><span class="p">,</span> <span class="n">k5</span> <span class="o">=</span> <span class="n">intrinsicModelParameters</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
<span class="n">iy</span><span class="p">,</span> <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
<span class="n">cx</span> <span class="o">=</span> <span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">mx</span><span class="p">)</span> <span class="o">/</span> <span class="n">fx</span>
<span class="n">cy</span> <span class="o">=</span> <span class="p">(</span><span class="n">iy</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">my</span><span class="p">)</span> <span class="o">/</span> <span class="n">fy</span>
<span class="n">cx</span> <span class="o">-=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">cy</span>
<span class="n">r2</span> <span class="o">=</span> <span class="n">cx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">cy</span><span class="o">**</span><span class="mi">2</span>
<span class="n">fradial</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">r2</span> <span class="o">*</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="n">r2</span> <span class="o">*</span> <span class="p">(</span><span class="n">k2</span> <span class="o">+</span> <span class="n">r2</span> <span class="o">*</span> <span class="n">k5</span><span class="p">))</span>
<span class="n">h</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cx</span> <span class="o">*</span> <span class="n">cy</span>
<span class="n">tx</span> <span class="o">=</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">h</span> <span class="o">+</span> <span class="n">k4</span> <span class="o">*</span> <span class="p">(</span><span class="n">r2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ty</span> <span class="o">=</span> <span class="n">k3</span> <span class="o">*</span> <span class="p">(</span><span class="n">r2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">k4</span> <span class="o">*</span> <span class="n">h</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">fradial</span> <span class="o">*</span> <span class="n">cx</span> <span class="o">+</span> <span class="n">tx</span>
<span class="n">dy</span> <span class="o">=</span> <span class="n">fradial</span> <span class="o">*</span> <span class="n">cy</span> <span class="o">+</span> <span class="n">ty</span>
<span class="n">fnorm</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ux</span> <span class="o">=</span> <span class="n">fnorm</span> <span class="o">*</span> <span class="n">dx</span>
<span class="n">uy</span> <span class="o">=</span> <span class="n">fnorm</span> <span class="o">*</span> <span class="n">dy</span>
<span class="n">uz</span> <span class="o">=</span> <span class="n">fnorm</span>
</pre></div>
</div>
<p><strong>Unit vectors based on a fish eye model</strong></p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="c1"># intrinsicModelID == 2:  # fish eye model</span>

<span class="n">fx</span><span class="p">,</span> <span class="n">fy</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">k3</span><span class="p">,</span> <span class="n">k4</span><span class="p">,</span> <span class="n">theta_max</span> <span class="o">=</span> <span class="n">intrinsicModelParameters</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
<span class="n">iy</span><span class="p">,</span> <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
<span class="n">cx</span> <span class="o">=</span> <span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">mx</span><span class="p">)</span> <span class="o">/</span> <span class="n">fx</span>
<span class="n">cy</span> <span class="o">=</span> <span class="p">(</span><span class="n">iy</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">my</span><span class="p">)</span> <span class="o">/</span> <span class="n">fy</span>
<span class="n">cx</span> <span class="o">-=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">cy</span>
<span class="n">theta_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">cy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">phi_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">theta_s</span><span class="p">,</span> <span class="n">theta_max</span><span class="p">)</span>
<span class="n">p_radial</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">phi_s</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="n">phi_s</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">k2</span> <span class="o">+</span> <span class="n">phi_s</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">k3</span> <span class="o">+</span> <span class="n">phi_s</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k4</span><span class="p">)))</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">theta_s</span> <span class="o">*</span> <span class="n">p_radial</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  <span class="c1"># -&gt; avoid surprises at image corners of extreme fisheyes</span>
<span class="n">ux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">((</span><span class="n">theta_s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">cx</span> <span class="o">/</span> <span class="n">theta_s</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)))</span>
<span class="n">uy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">((</span><span class="n">theta_s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">cy</span> <span class="o">/</span> <span class="n">theta_s</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)))</span>
<span class="n">uz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
<p>For rotating points or rays in space a three dimensional rotation matrix is required. For an example implementation see the code block below.</p>
<p><strong>Rotation matrix in 3D space</strong></p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rotMat</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">:</span>
        <span class="n">lr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">lr</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">lr</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">lr</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">lr</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">R</span>
</pre></div>
</div>
<p>The following code block demonstrates the calculation routine for rotated floor distances, i.e. the building block of this verification method.
Based on two rotation matrices the distances of the floor pixels are calculated:</p>
<ul class="simple">
<li><p>R corresponds to the rotation matrix as determined by the user input extrinsic calibration parameters.</p></li>
<li><p>RR corresponds to the additional rotation matrix introduce to simulate rotations in additional roll and pitch angles.</p></li>
</ul>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="c1"># modelID3D = 0 or 2        depending on the O3R camera head</span>
<span class="c1"># imager_size = [172,224]   expects a image dimension of (172, 224) == 38k imager</span>
<span class="c1"># intrinsics3D              intrinsic camera calibration parameters, see functions above</span>

<span class="k">def</span> <span class="nf">get_rotated_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">RR</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="n">ux</span><span class="p">,</span> <span class="n">uy</span><span class="p">,</span> <span class="n">uz</span> <span class="o">=</span> <span class="n">intrinsic_projection</span><span class="p">(</span><span class="n">modelID3D</span><span class="p">,</span> <span class="n">intrinsics3D</span><span class="p">,</span> <span class="o">*</span><span class="n">imager_size</span><span class="p">)</span>

    <span class="n">e_flatten</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">ux</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">uy</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">uz</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">e_rot</span> <span class="o">=</span> <span class="p">(</span><span class="n">RR</span> <span class="o">@</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">e_flatten</span><span class="p">)</span>
    <span class="n">e_3</span> <span class="o">=</span> <span class="n">e_rot</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">d_rot_flat</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="n">e_3</span> <span class="o">*</span> <span class="n">extrinsic3D</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">d_rot_flat</span>

<span class="n">d_rot</span> <span class="o">=</span> <span class="n">d_rot_flat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">imager_size</span><span class="p">)</span>
</pre></div>
</div>
<p>For easier calculation purpose the unit vectors matrices, which are 2D matrices of the same dimension as the image, have to be flattened.
A consecutive left side matrix multiplication of combined rotation matrices gives the rotated unit vectors in RCS space.
The expected floor distance (per pixel) can be calculated via a scalar multiplication of <code class="docutils literal notranslate"><span class="pre">1/unit__vector_in_Z</span></code> and <code class="docutils literal notranslate"><span class="pre">trans</span> <span class="pre">Z</span></code>: i.e. <code class="docutils literal notranslate"><span class="pre">d</span> <span class="pre">=</span> <span class="pre">(-1</span> <span class="pre">/</span> <span class="pre">e_3)</span> <span class="pre">*</span> <span class="pre">extrinsic3D[2]</span></code></p>
<p>The mathematical concept behind this idea is a simple linear equation:</p>
<p><code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">unit_vectors</span> <span class="pre">*</span> <span class="pre">d</span> <span class="pre">+</span> <span class="pre">translation</span> <span class="pre">=</span> <span class="pre">[a,b,0]</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">[ux,</span> <span class="pre">uy,</span> <span class="pre">uz]</span> <span class="pre">*</span> <span class="pre">d</span> <span class="pre">+</span> <span class="pre">[trans_x,</span> <span class="pre">trans_y,</span> <span class="pre">trans_z]</span> <span class="pre">=</span> <span class="pre">[a,b,0]</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">[ex,</span> <span class="pre">ey,</span> <span class="pre">ez]</span> <span class="pre">*</span> <span class="pre">d</span> <span class="pre">+</span> <span class="pre">[trans_x,</span> <span class="pre">trans_y,</span> <span class="pre">trans_z]</span> <span class="pre">=</span> <span class="pre">[a,b,0]</span></code></p>
<p>solving this equation for <code class="docutils literal notranslate"><span class="pre">d</span></code> gives:</p>
<p><code class="docutils literal notranslate"><span class="pre">d</span> <span class="pre">=</span> <span class="pre">(-1</span> <span class="pre">/</span> <span class="pre">ez)</span> <span class="pre">*</span> <span class="pre">trans_z</span> <span class="pre">=</span> <span class="pre">(-1</span> <span class="pre">/</span> <span class="pre">e_3)</span> <span class="pre">*</span> <span class="pre">extrinsic3D[2]</span></code></p>
</div>
<div class="section" id="measured-floor-plane-distance-and-rotated-reference-floor-plane-distances-comparison">
<h3>Measured floor plane distance and rotated reference floor plane distances comparison<a class="headerlink" href="#measured-floor-plane-distance-and-rotated-reference-floor-plane-distances-comparison" title="Permalink to this headline"></a></h3>
<p>Based on the described concepts above reference floor plane can be estimated in RCS space.</p>
<p>Rotating this reference floor plane with additional rotation matrices of the critical extrinsic calibration angles (in RCS space) provides the distance boundaries per pixel: i.e. a distance map per rotation.</p>
<p>For all possible angle rotations in roll and pitch angle the distance map has to be compared for smaller and larger distances per pixel. These lower and upper boundaries determine the validity of the actual measured distances as a binary map.</p>
</div>
</div>
<div class="section" id="applications-of-this-extrinsic-calibration-verification-method">
<h2>Applications of this extrinsic calibration verification method<a class="headerlink" href="#applications-of-this-extrinsic-calibration-verification-method" title="Permalink to this headline"></a></h2>
<p>Below a couple of application of a extrinsic calibration verification tool are sketched.</p>
<div class="section" id="cad-based-extrinsic-calibration-parameters">
<h3>CAD based extrinsic calibration parameters<a class="headerlink" href="#cad-based-extrinsic-calibration-parameters" title="Permalink to this headline"></a></h3>
<p>Using the CAD based calculations of the 3D extrinsics pose is a valid option if production and assembly accuracy is sufficient to ensure the demanded extrinsic calibrations accuracies, e.g. 1 deg per rotation angle parameters and 1 cm per translation parameter.</p>
<p>A sanity check that the calculated parameters are correct and no mechanical designs have been altered since the calculation of the parameters is highly suggested.</p>
<p>For this application the camera heads are mounted in their final position and the CAD based extrinsic calibration parameters JSON set.
The validation method gives a good indication if the calibration matches the expected distance measurements for an “empty / no objects just floor” scene.</p>
</div>
<div class="section" id="verifying-other-extrinsic-calibration-methods">
<h3>Verifying other extrinsic calibration methods<a class="headerlink" href="#verifying-other-extrinsic-calibration-methods" title="Permalink to this headline"></a></h3>
<p>Other calibration tools such as the single frame checkerboard calibration routine and the multi frame calibration routine provide an estimation of the pose transformation.</p>
<p>The tools are based on a 2D PnP based approaches.
Systematic (implicit) errors between the placement of the 3D lens inside the camera heads housing and other biases might not be apparent when using these routines.
These errors might include:</p>
<ul class="simple">
<li><p>wrong reference points</p></li>
<li><p>unintended rotations of the sensor relative to the RCS frame</p></li>
<li><p>wrong distance reference points when manually measuring the checkerboard position in relation to the RCS</p></li>
<li><p>alterations in the positioning of the robot wrt to the calibration patter and vice versa</p></li>
</ul>
<p>An additional sanity check based on the native 3D measurements and estimated extrinsic calibration can indicate possible systematic errors. This indication should be used to verify the result of the calibration right after its application and in regular time intervals to find possible alterations of “calibration stations”.</p>
</div>
<div class="section" id="sanity-checks-in-production-after-modification">
<h3>Sanity checks: in production - after modification<a class="headerlink" href="#sanity-checks-in-production-after-modification" title="Permalink to this headline"></a></h3>
<p>Sanity checks of the extrinsic calibration are highly suggested. They should be done in regular time intervals and after specific events:</p>
<ul class="simple">
<li><p>Regular time intervals: depending on the rigidity of the mounting structure a regular sanity check of the extrinsic calibration might be required</p></li>
<li><p>Specific events: after specific events a sanity check and possible recalibration might be required. These include:</p>
<ul>
<li><p>After shipment: after shipping the robot between facilities at least a calibration verification is required.</p></li>
<li><p>After high mechanical stress events such as: a verification and recalibration is required</p>
<ul>
<li><p>Dropping of an AGV</p></li>
<li><p>Accidents of any kind and severity</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Replacement of O3R hardware components: any replacement of O3R hardware (VPUs or camera heads) requires at least a sanity check of the calibration and possible recalibration.</p></li>
</ul>
</div>
</div>
<div class="section" id="example-application-of-the-extrinsic-calibration-verification-tool">
<h2>Example application of the extrinsic calibration verification tool<a class="headerlink" href="#example-application-of-the-extrinsic-calibration-verification-tool" title="Permalink to this headline"></a></h2>
<p>For demonstration purposes two sets of evaluations for different max / min allowed rotation angles are shown below.
The extrinsic calibration in this data as input by the user is off in pitch angle by ~ 3.5 deg.
For this reason the calibration verification script fails.</p>
<p><strong>The ODS extrinsic calibration rotation requirement calls for a angle accuracy of [-1, +1] deg. This is equivalent for the first set of images.</strong></p>
<div class="section" id="max-allowed-rotation-angle-inaccuracy-1-1-deg">
<h3>Max allowed rotation angle inaccuracy: [-1, +1] deg<a class="headerlink" href="#max-allowed-rotation-angle-inaccuracy-1-1-deg" title="Permalink to this headline"></a></h3>
<p>This plot shows the floor pixel distance measurement distribution.</p>
<p>The plot shows the measured distances of the floor in yellow vs the expected floor distances for a perfect calibration in red: angle bisector.</p>
<p>The green dots mark the upper and lower boundaries for an acceptable calibration result with difference in angles (roll and pitch = [+1 deg, -1 deg]) as their respective distance measurements.</p>
<p>As can be seen in this plot most yellow points, i.e. actual distance measurements, are outside the acceptable distance range - green points. This means the calibration result is not valid.</p>
<p><img alt="Floor distance plot as measured by the camera" src="../../../../_images/floor_distance_plot_orig.png" /></p>
<p>Based on the maximum allowed rotation inaccuracies a distance map can be built: i.e. lower and upper distance thresholds per imager matrix pixel.</p>
<p><img alt="Distance image based on angle rotations" src="../../../../_images/distance_image_based_on_max_rot.png" /></p>
<p>Based on these distance maps the actual distance measurements can be verified by testing if measurement values are inside the allowed range per pixel.
<img alt="Valid floor pixels" src="../../../../_images/valid_floor_pixels.png" /></p>
<p>In this case the extrinsic calibration user input is off too much for even a single pixel to be considered valid. The valid floor pixel map is a uniform invalid matrix. The verification method raises a <code class="docutils literal notranslate"><span class="pre">Assertion</span> <span class="pre">error</span></code>.</p>
</div>
<div class="section" id="max-allowed-rotation-angle-inaccuracy-3-3-deg">
<h3>Max allowed rotation angle inaccuracy: [-3, +3] deg<a class="headerlink" href="#max-allowed-rotation-angle-inaccuracy-3-3-deg" title="Permalink to this headline"></a></h3>
<p><img alt="Distance image based on angle rotations" src="../../../../_images/distance_image_based_on_max_rot1.png" />
<img alt="Floor distance plot as measured by the camera" src="../../../../_images/floor_distance_plot_orig1.png" />
<img alt="Valid floor pixels" src="../../../../_images/valid_floor_pixels1.png" /></p>
<p>For a relaxed set of angle rotation accuracies [-3, +3] deg, the valid floor pixel map includes possible valid pixels.
None the less the number of allowed invalid pixels is larger than the threshold. The verification method  raises a <code class="docutils literal notranslate"><span class="pre">Assertion</span> <span class="pre">error</span></code>.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../MCC/multi_frame_calibration.html" class="btn btn-neutral float-left" title="Automated camera head calibration tools" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../VPUCalibration/README.html" class="btn btn-neutral float-right" title="VPU extrinsic calibration" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, ifm CSR.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>