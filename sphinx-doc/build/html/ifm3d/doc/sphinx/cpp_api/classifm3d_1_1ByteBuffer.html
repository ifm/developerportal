<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ifm3d: ifm3d::ByteBuffer&lt; Derived &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ifm3d
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classifm3d_1_1ByteBuffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classifm3d_1_1ByteBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ifm3d::ByteBuffer&lt; Derived &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="byte__buffer_8h_source.html">byte_buffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0998491e0f87a8bcee453ef5f832a8e9"><td class="memItemLeft" align="right" valign="top"><a id="a0998491e0f87a8bcee453ef5f832a8e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr</b> = std::shared_ptr&lt; <a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a>&lt; Derived &gt; &gt;</td></tr>
<tr class="separator:a0998491e0f87a8bcee453ef5f832a8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4241054150924d625eeae1f318139ac7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a4241054150924d625eeae1f318139ac7">ByteBuffer</a> ()</td></tr>
<tr class="separator:a4241054150924d625eeae1f318139ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235e2900548699f02e8f11044cc67117"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a235e2900548699f02e8f11044cc67117">~ByteBuffer</a> ()</td></tr>
<tr class="separator:a235e2900548699f02e8f11044cc67117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc96ad2b22f5e4e2dadbccc2bff934d2"><td class="memItemLeft" align="right" valign="top"><a id="adc96ad2b22f5e4e2dadbccc2bff934d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ByteBuffer</b> (<a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a> &amp;&amp;)</td></tr>
<tr class="separator:adc96ad2b22f5e4e2dadbccc2bff934d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6718b57540c54da9b166b51641cc17d9"><td class="memItemLeft" align="right" valign="top"><a id="a6718b57540c54da9b166b51641cc17d9"></a>
<a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a> &amp;&amp;)</td></tr>
<tr class="separator:a6718b57540c54da9b166b51641cc17d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad443a02ca3ddbe716984bef0795c6a23"><td class="memItemLeft" align="right" valign="top"><a id="ad443a02ca3ddbe716984bef0795c6a23"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ByteBuffer</b> (const <a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a> &amp;src_buff)</td></tr>
<tr class="separator:ad443a02ca3ddbe716984bef0795c6a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae679e8d5339d26fd9bfc1592af9347f8"><td class="memItemLeft" align="right" valign="top"><a id="ae679e8d5339d26fd9bfc1592af9347f8"></a>
<a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a> &amp;src_buff)</td></tr>
<tr class="separator:ae679e8d5339d26fd9bfc1592af9347f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecc681f8da1ee380c48ac04ed82c197"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#aaecc681f8da1ee380c48ac04ed82c197">Bytes</a> ()</td></tr>
<tr class="separator:aaecc681f8da1ee380c48ac04ed82c197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e93589d149d669063741b008b1d073a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a4e93589d149d669063741b008b1d073a">Dirty</a> () const noexcept</td></tr>
<tr class="separator:a4e93589d149d669063741b008b1d073a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744d4ce0f4ade370de545170f31cfc60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a744d4ce0f4ade370de545170f31cfc60">SetBytes</a> (std::vector&lt; std::uint8_t &gt; &amp;buff, bool copy=false)</td></tr>
<tr class="separator:a744d4ce0f4ade370de545170f31cfc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198e4ef7cf17afe358dec8ca0e7bb4db"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a198e4ef7cf17afe358dec8ca0e7bb4db">Extrinsics</a> ()</td></tr>
<tr class="separator:a198e4ef7cf17afe358dec8ca0e7bb4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14b5cc1efcadeea23da3e0f8ffa9f16"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#ad14b5cc1efcadeea23da3e0f8ffa9f16">Intrinsics</a> ()</td></tr>
<tr class="separator:ad14b5cc1efcadeea23da3e0f8ffa9f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe3a81ddfc28dc7e5f3852059b8441e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a4fe3a81ddfc28dc7e5f3852059b8441e">InverseIntrinsics</a> ()</td></tr>
<tr class="separator:a4fe3a81ddfc28dc7e5f3852059b8441e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942b732624f6dd8008aa4501a7e5afc5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a942b732624f6dd8008aa4501a7e5afc5">ExposureTimes</a> ()</td></tr>
<tr class="separator:a942b732624f6dd8008aa4501a7e5afc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19eccf6455b5ad3deb0c40a2cacc1c75"><td class="memItemLeft" align="right" valign="top">ifm3d::TimePointT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a19eccf6455b5ad3deb0c40a2cacc1c75">TimeStamp</a> ()</td></tr>
<tr class="separator:a19eccf6455b5ad3deb0c40a2cacc1c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9069aa2afbce6f8a14e1fdd14d20d2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; ifm3d::TimePointT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a8d9069aa2afbce6f8a14e1fdd14d20d2">TimeStamps</a> ()</td></tr>
<tr class="separator:a8d9069aa2afbce6f8a14e1fdd14d20d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39ced7bc4b50843e04368b577382d8b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#ac39ced7bc4b50843e04368b577382d8b">IlluTemp</a> ()</td></tr>
<tr class="separator:ac39ced7bc4b50843e04368b577382d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd79ee0d4ba1152015ecd54cf59b02a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a8bd79ee0d4ba1152015ecd54cf59b02a">JSONModel</a> ()</td></tr>
<tr class="separator:a8bd79ee0d4ba1152015ecd54cf59b02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2d81476f104e6625c588474bcc7700"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a0e2d81476f104e6625c588474bcc7700">Organize</a> ()</td></tr>
<tr class="separator:a0e2d81476f104e6625c588474bcc7700"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aeb79544f5a59af1b17a983b6f1bf45ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb79544f5a59af1b17a983b6f1bf45ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#aeb79544f5a59af1b17a983b6f1bf45ba">ImCreate</a> (ifm3d::image_chunk im, std::uint32_t fmt, std::size_t idx, std::uint32_t width, std::uint32_t height, int nchan, std::uint32_t npts, const std::vector&lt; std::uint8_t &gt; &amp;bytes)</td></tr>
<tr class="separator:aeb79544f5a59af1b17a983b6f1bf45ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5594cd7bb84894800d3a16ac2f55bac7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5594cd7bb84894800d3a16ac2f55bac7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a5594cd7bb84894800d3a16ac2f55bac7">CloudCreate</a> (std::uint32_t fmt, std::size_t xidx, std::size_t yidx, std::size_t zidx, std::uint32_t width, std::uint32_t height, std::uint32_t npts, const std::vector&lt; std::uint8_t &gt; &amp;bytes)</td></tr>
<tr class="separator:a5594cd7bb84894800d3a16ac2f55bac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcdd6e22ffd17647367f5f0889b9463"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a3fcdd6e22ffd17647367f5f0889b9463">_SetDirty</a> (bool flg) noexcept</td></tr>
<tr class="separator:a3fcdd6e22ffd17647367f5f0889b9463"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3e01fe2938a5ee313c70de5ae31c70f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a3e01fe2938a5ee313c70de5ae31c70f0">dirty_</a></td></tr>
<tr class="separator:a3e01fe2938a5ee313c70de5ae31c70f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacec5c8eabc5c0b29024f376e2061743"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#aacec5c8eabc5c0b29024f376e2061743">bytes_</a></td></tr>
<tr class="separator:aacec5c8eabc5c0b29024f376e2061743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a469e57ed2bc6d70a9bb415af35a80"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a09a469e57ed2bc6d70a9bb415af35a80">extrinsics_</a></td></tr>
<tr class="separator:a09a469e57ed2bc6d70a9bb415af35a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb65be04777acfcd567e28b341e723c4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#afb65be04777acfcd567e28b341e723c4">intrinsics_</a></td></tr>
<tr class="separator:afb65be04777acfcd567e28b341e723c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6242f8b07e12b339fd675cf15fe7a7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a3f6242f8b07e12b339fd675cf15fe7a7">inverseIntrinsics_</a></td></tr>
<tr class="separator:a3f6242f8b07e12b339fd675cf15fe7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26a7c2fa9775fc930857ae6b343f13b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#af26a7c2fa9775fc930857ae6b343f13b">exposure_times_</a></td></tr>
<tr class="separator:af26a7c2fa9775fc930857ae6b343f13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5f3bc241807b3a1b5497258192df69"><td class="memItemLeft" align="right" valign="top">std::vector&lt; ifm3d::TimePointT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a6a5f3bc241807b3a1b5497258192df69">time_stamps_</a></td></tr>
<tr class="separator:a6a5f3bc241807b3a1b5497258192df69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a455c85de2dfba6eb4e93c365bb75b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#ae2a455c85de2dfba6eb4e93c365bb75b">illu_temp_</a></td></tr>
<tr class="separator:ae2a455c85de2dfba6eb4e93c365bb75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24424fac54ddd40ac83dbc720e6dd250"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classifm3d_1_1ByteBuffer.html#a24424fac54ddd40ac83dbc720e6dd250">json_model_</a></td></tr>
<tr class="separator:a24424fac54ddd40ac83dbc720e6dd250"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Derived&gt;<br />
class ifm3d::ByteBuffer&lt; Derived &gt;</h3>

<p>The <a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a> class is used to hold a validated byte buffer from the sensor that represents a single time-synchronized set of images based on the current schema mask set on the active framegrabber.</p>
<p>The <a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a> imposes no specific image or point cloud data structure. This class is intended to be subclassed where more user-friendly data structures can be used to gain access to the bytes in a semantically meaningful manner.</p>
<p>There are two primary interfaces (documented below) that image container developers should implement. They are:</p>
<p><code>ImCreate</code> <code>CloudCreate</code></p>
<p>These functions will be called as customization hooks at the time of parsing the raw image bytes from the sensor. It is the contract of this interface that all calls to <code>ImCreate</code> will be made before the single call to <code>CloudCreate</code>. The reason for this part of the contract is to give all image container implementers the ability to set the point cloud intensity data from one of the image containers. That is, at the time of calling <code>CloudCreate</code> all image data (e.g., amplitude or gray) data are avaialble for coloring the point cloud intensity pixels. In addition, it is guaranteed that the first call to <code>ImCreate</code> will be the confidence image. So, the confidence bits for a given pixel can be consulting while constructing the payload images.</p>
<p>We note that the ploymorphic behaviors implemented by this class are static (resolved at compile-time via CRTP) rather than dynamic at runtime (via a vtable). This is why there are no interface functions declared <code>virtual</code>.</p>
<p>NOTE: The <a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a> is NOT thread safe! </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4241054150924d625eeae1f318139ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4241054150924d625eeae1f318139ac7">&#9670;&nbsp;</a></span>ByteBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::<a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default initializes instance vars </p>

</div>
</div>
<a id="a235e2900548699f02e8f11044cc67117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235e2900548699f02e8f11044cc67117">&#9670;&nbsp;</a></span>~ByteBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::~<a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>RAII dealloc </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3fcdd6e22ffd17647367f5f0889b9463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fcdd6e22ffd17647367f5f0889b9463">&#9670;&nbsp;</a></span>_SetDirty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::_SetDirty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mutates the dirty flag </p>

</div>
</div>
<a id="aaecc681f8da1ee380c48ac04ed82c197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecc681f8da1ee380c48ac04ed82c197">&#9670;&nbsp;</a></span>Bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint8_t&gt; <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::Bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a copy of the underlying byte buffer read from the camera </p>

</div>
</div>
<a id="a5594cd7bb84894800d3a16ac2f55bac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5594cd7bb84894800d3a16ac2f55bac7">&#9670;&nbsp;</a></span>CloudCreate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::CloudCreate </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>xidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>yidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>zidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>npts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is part of the <a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a> interface, intended to be overloaded by image container implementers. It is a callback hook that is called once for each frame recieved by the framegrabber if the cartesian data are specified in the current pcic schema. All 2D image callbacks (i.e., <code>ImCreate</code>) are guaranteed to be called prior to this function &ndash; this is to allow for "coloring" the intensity channel of the point cloud with data from one of the 2D images (already parsed). It is also implied that for a given frame, before this function is called, the image container implementer will have had the opportunity to construct the confidence image associated with this frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>The pixel format of the image (see <code>ifm3d::pixel_format</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xidx</td><td>The index into <code>bytes</code> where the x-coords start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yidx</td><td>The index into <code>bytes</code> where the y-coords start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zidx</td><td>The index into <code>bytes</code> where the z-coords start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Number of columns in the point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Number of rows in the point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npts</td><td>Total points in the point cloud (width * height) @paramin] bytes A const reference to the byte buffer to process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e93589d149d669063741b008b1d073a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e93589d149d669063741b008b1d073a">&#9670;&nbsp;</a></span>Dirty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::Dirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the state of the &lsquo;dirty&rsquo; flag </p>

</div>
</div>
<a id="a942b732624f6dd8008aa4501a7e5afc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942b732624f6dd8008aa4501a7e5afc5">&#9670;&nbsp;</a></span>ExposureTimes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint32_t&gt; <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::ExposureTimes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a 3-element vector containing the exposure times (usec) for the current frame. Unused exposure times are reported as 0.</p>
<p>If all elements are reported as 0 either the exposure times are not configured to be returned back in the data stream from the camera or an error in parsing them has occured. </p>

</div>
</div>
<a id="a198e4ef7cf17afe358dec8ca0e7bb4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198e4ef7cf17afe358dec8ca0e7bb4db">&#9670;&nbsp;</a></span>Extrinsics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::Extrinsics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a 6-element vector containing the extrinsic calibration of the camera. NOTE: This is the extrinsics WRT to the ifm optical frame.</p>
<p>The elements are: tx, ty, tz, rot_x, rot_y, rot_z</p>
<p>Translation units are mm, rotations are degrees</p>
<p>Users of this library are highly DISCOURAGED from using the extrinsic calibration data stored on the camera itself. </p>

</div>
</div>
<a id="ac39ced7bc4b50843e04368b577382d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39ced7bc4b50843e04368b577382d8b">&#9670;&nbsp;</a></span>IlluTemp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::IlluTemp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the temperature of the illumination unit.</p>
<p>NOTE: To get the temperature of the illumination unit to the frame, you need to make sure your current pcic schema asks for it. </p>

</div>
</div>
<a id="aeb79544f5a59af1b17a983b6f1bf45ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb79544f5a59af1b17a983b6f1bf45ba">&#9670;&nbsp;</a></span>ImCreate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::ImCreate </td>
          <td>(</td>
          <td class="paramtype">ifm3d::image_chunk&#160;</td>
          <td class="paramname"><em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nchan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>npts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is part of the <a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a> interface, intended to be overloaded by image container implementers. It is a callback hook that is called once for each 2D image type specified in the current pcic schema for each frame recieved by the framegrabber. All 2D image callbacks are guaranteed to be called prior to the <code>CloudCreate</code> callback &ndash; this is to allow for "coloring" the intensity channel of the point cloud with data from one of the 2D images (already parsed)</p>
<p>For a given frame, the first <code>ImCreate</code> callback will be the confidence image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">im</td><td>The 2D image type currently being processed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>The pixel format of the image (see <code>ifm3d::pixel_format</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The index into the byte buffer, <code>bytes</code>, as to where the pixel data begin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The image width (pixels) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The image height (pixels) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nchan</td><td>The number of channels in the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npts</td><td>The total number of image points (width * height) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>A const reference to the byte buffer to process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad14b5cc1efcadeea23da3e0f8ffa9f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14b5cc1efcadeea23da3e0f8ffa9f16">&#9670;&nbsp;</a></span>Intrinsics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::Intrinsics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a 16-element vector containing the intrinsic calibration of the camera.</p>
<p>The elements are:</p>
<p>Name Data type Unit Description fx 32 bit float px Focal length of the camera in the sensor's x axis direction. fy 32 bit float px Focal length of the camera in the sensor's yaxis direction. mx 32 bit float px Main point in the sensor's x direction my 32 bit float px Main point in the sensor's y direction alpha 32 bit float dimensionless Skew parameter k1 32 bit float dimensionless First radial distortion coefficient k2 32 bit float dimensionless Second radial distortion coefficient k5 32 bit float dimensionless Third radial distortion coefficient k3 32 bit float dimensionless First tangential distortion coefficient k4 32 bit float dimensionless Second tangential distortion coefficient transX 32 bit float mm Translation along x-direction in meters. transY 32 bit float mm Translation along y-direction in meters. transZ 32 bit float mm Translation along z-direction in meters. rotX 32 bit float degree Rotation along x-axis in radians. Positive values indicate clockwise rotation. rotY 32 bit float degree Rotation along y-axis in radians. Positive values indicate clockwise rotation. rotZ 32 bit float degree Rotation along z-axis in radians. Positive values indicate clockwise rotation. </p>

</div>
</div>
<a id="a4fe3a81ddfc28dc7e5f3852059b8441e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe3a81ddfc28dc7e5f3852059b8441e">&#9670;&nbsp;</a></span>InverseIntrinsics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::InverseIntrinsics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a 16-element vector containing the inverse intrinsic calibration of the camera. See <a class="el" href="classifm3d_1_1ByteBuffer.html#ad14b5cc1efcadeea23da3e0f8ffa9f16">Intrinsics()</a> for further information </p>

</div>
</div>
<a id="a8bd79ee0d4ba1152015ecd54cf59b02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd79ee0d4ba1152015ecd54cf59b02a">&#9670;&nbsp;</a></span>JSONModel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::JSONModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the JSON model of the output of the active application</p>
<p>NOTE: To get the JSON data for the application running on the device, you need to make sure your current pcic schema asks for it by including ifm3d::JSON_MODEL in the schema. This will return a blank JSON string ("{}") for <a class="el" href="classifm3d_1_1Camera.html">Camera</a> devices like the O3D303, versus ifm Smart Sensors like the O3D302. </p>

</div>
</div>
<a id="a0e2d81476f104e6625c588474bcc7700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2d81476f104e6625c588474bcc7700">&#9670;&nbsp;</a></span>Organize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::Organize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the interface hook that synchronizes the internally wrapped byte buffer with the semantically meaningful image/cloud data structures. Within the overall <code>ifm3d</code> framework, this function is called by the <code><a class="el" href="classifm3d_1_1FrameGrabber.html">FrameGrabber</a></code> when a complete "frame packet" has been recieved. This then parses the bytes and, in-line, will statically dispatch to the underly dervied class to populate their image/cloud data structures.</p>
<p>Additionally, this function will populate the extrinsics, exposure times, timestamp, and illumination temperature as appropriate and subject to the current pcic schema. </p>

</div>
</div>
<a id="a744d4ce0f4ade370de545170f31cfc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744d4ce0f4ade370de545170f31cfc60">&#9670;&nbsp;</a></span>SetBytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::SetBytes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the data from the passed in &lsquo;buff&rsquo; to the internally wrapped byte buffer. This function assumes the passed in &lsquo;buff&rsquo; is valid.</p>
<p>By default, this function will take in <code>buff</code> and <code>swap</code> contents with its internal buffer so that the operation is O(1) and requires no data copies. If you want copy behavior, specify the <code>copy</code> flag and complexity will be linear in the size of the byte buffer which is driven by the schema mask currently applied to the running framegrabber.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buff</td><td>Raw data bytes to copy/swap to internal buffers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>If true, the data are copied from <code>buff</code> to the internally wrapped buffer and <code>buff</code> will remain unchanged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19eccf6455b5ad3deb0c40a2cacc1c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19eccf6455b5ad3deb0c40a2cacc1c75">&#9670;&nbsp;</a></span>TimeStamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ifm3d::TimePointT <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::TimeStamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the time stamp of the image data.</p>
<p>NOTE: To get the timestamp of the confidence data, you need to make sure your current pcic schema mask have enabled confidence data. </p>

</div>
</div>
<a id="a8d9069aa2afbce6f8a14e1fdd14d20d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9069aa2afbce6f8a14e1fdd14d20d2">&#9670;&nbsp;</a></span>TimeStamps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;ifm3d::TimePointT&gt; <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::TimeStamps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the timestamp of phase data for O3R device</p>
<p>NOTE: For O3D and O3X camera it only returns confidence <a class="el" href="classifm3d_1_1Image.html" title="The class Image represent a STL conatiner to stored image data from the ifm devices in 2 dimension an...">Image</a> timestamp </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aacec5c8eabc5c0b29024f376e2061743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacec5c8eabc5c0b29024f376e2061743">&#9670;&nbsp;</a></span>bytes_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint8_t&gt; <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::bytes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Raw bytes read off the wire from the camera. </p>

</div>
</div>
<a id="a3e01fe2938a5ee313c70de5ae31c70f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e01fe2938a5ee313c70de5ae31c70f0">&#9670;&nbsp;</a></span>dirty_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::dirty_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag used to indicate if the wrapped byte buffer needs to be &lsquo;Organized&rsquo;. I.e., in a subclass, this would indicate if your parsed out image data structures need to be synchronized to the underlying byte buffer or not. </p>

</div>
</div>
<a id="af26a7c2fa9775fc930857ae6b343f13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26a7c2fa9775fc930857ae6b343f13b">&#9670;&nbsp;</a></span>exposure_times_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint32_t&gt; <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::exposure_times_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exposure time(s) (up to 3), registered to the current frame. </p>

</div>
</div>
<a id="a09a469e57ed2bc6d70a9bb415af35a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a469e57ed2bc6d70a9bb415af35a80">&#9670;&nbsp;</a></span>extrinsics_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::extrinsics_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extrinsic calibration WRT camera optical frame: tx, ty, tz, rotx, roty, rotz. Translation units are mm, rotational units are degrees. </p>

</div>
</div>
<a id="ae2a455c85de2dfba6eb4e93c365bb75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a455c85de2dfba6eb4e93c365bb75b">&#9670;&nbsp;</a></span>illu_temp_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::illu_temp_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Temperature of the illumination unit synchronized in time with the current frame data. </p>

</div>
</div>
<a id="afb65be04777acfcd567e28b341e723c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb65be04777acfcd567e28b341e723c4">&#9670;&nbsp;</a></span>intrinsics_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::intrinsics_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Intrinsic calibration WRT camera lense </p>

</div>
</div>
<a id="a3f6242f8b07e12b339fd675cf15fe7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6242f8b07e12b339fd675cf15fe7a7">&#9670;&nbsp;</a></span>inverseIntrinsics_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::inverseIntrinsics_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverse intrinsic calibration WRT camera lense: </p>

</div>
</div>
<a id="a24424fac54ddd40ac83dbc720e6dd250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24424fac54ddd40ac83dbc720e6dd250">&#9670;&nbsp;</a></span>json_model_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::json_model_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>JSON string of the active application output </p>

</div>
</div>
<a id="a6a5f3bc241807b3a1b5497258192df69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5f3bc241807b3a1b5497258192df69">&#9670;&nbsp;</a></span>time_stamps_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;ifm3d::TimePointT&gt; <a class="el" href="classifm3d_1_1ByteBuffer.html">ifm3d::ByteBuffer</a>&lt; Derived &gt;::time_stamps_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classifm3d_1_1Camera.html">Camera</a> timestamps of the current frame </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/ifm3d/modules/framegrabber/include/ifm3d/fg/<a class="el" href="byte__buffer_8h_source.html">byte_buffer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ifm3d</b></li><li class="navelem"><a class="el" href="classifm3d_1_1ByteBuffer.html">ByteBuffer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
